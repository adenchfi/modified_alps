<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>ALPS Project: alea/simpleobservable.h</title>
</head>
  <body>
     
<h1> ALPS Project: alea library</h1>
     
<h2> Header file <b>alea/simpleobservable.h</b></h2>
   This header contains the class to record standard Monte Carlo measurements. 
  
<h3>Synopsis</h3>
    
<blockquote>      
  <pre>namespace alps {<br><typename obs_value_slice&lt;t,s=""><br>template &lt;class T=double&gt;<br>class SimpleObservable <br>  : public AbstractSimpleObservable&lt;T&gt;, <br>    public RecordableObservable&lt;T&gt;<br>{<br>public:<br>  typedef T       value_type;<br>  typedef ...     time_type;<br>  typedef ...     count_type;<br>  typedef ...     result_type;<br>  typedef BINNING binning_type;<br><br></typename>  enum { version=...};<typename
 obs_value_slice&lt;t,s=""><br></typename><br>  SimpleObservable(const std::string&amp; name="" ,uint32_t s=0);<br>&nbsp; SimpleObservable(const std::string&amp; name ,const binning_type&amp;);<br><br>  uint32_t version_id() const;<br>  <br>  Observable* clone() const;<br><br>  void output(std::ostream&amp;) const;<br>  void reset(bool =false);<br>  <br>  result_type mean() const;<br>  bool has_variance() const;<br>  result_type variance() const;<br>  result_type error() const;<br>  count_type count() const;<br>  bool has_minmax() const;<br>  value_type min() const;<br>  value_type max() const;<br>  bool has_tau() const;<br>  time_type tau() const;<br>  <br>  virtual bool is_thermalized() const;<br>  uint32_t get_thermalization() const;<br>  bool can_set_thermalization() const;<br>  <br>  void operator&lt;&lt;(const T&amp; x);<br><br>  count_type bin_size() const;<br>  void set_bin_size(count_type s);<br>  count_type bin_number() const;<br>  count_type bin_number2() const;<br>  count_type max_bin_number() const;<br>  void set_bin_number(count_type n);<br>  const value_type&amp; bin_value(count_type n) const;<br>  const value_type&amp; bin_value2(count_type n) const;<br>  <br>  void save(ODump&amp; dump) const;<br>  void load(IDump&amp; dump);<br><br>  void compact();<typename
 obs_value_slice&lt;t,s=""><t><br>};<br><br>}<br><br></t></typename></pre>
  </blockquote>
       
<h3>The <tt>SimpleObservable</tt> class</h3>
    is the actual class for standard observables to perform measurements
with.  It is templated on the data type for the measurements and on the 
<a href="binning.html">binning strategy</a> In addition to implementations
to all virtual function members of the base classes&nbsp;<a
 href="recordableobservable.html"><tt>RecordableObservable</tt></a>. <a
 href="abstractsimpleobservable.html"><tt>AbstractSimpleObservable</tt></a>, 
and indirectly from <a href="observable.html"><tt>Observable</tt></a>  it 
provides the following members:   
<blockquote>     
  <pre>typedef BINNING binning_type;<br></pre>
  </blockquote>
   the binning strategy type.   
<blockquote>     
  <pre>enum { version=...};<br></pre>
  </blockquote>
   a compile-time constant, same as <tt>version_id</tt>  
<blockquote>     
  <pre>BasicSimpleObservable(const std::string&amp; name ,const binning_type&amp;);<br>BasicSimpleObservable(const std::string&amp; name ,uint32_t s=0);<br></pre>
  </blockquote>
   The constructors take a second argument which is used to initialize the 
binning startegies. See the documentation for <a href="binning.html"> binning 
strategies</a> for more information.   
<HR>
<ADDRESS>
    <p>copyright (c) 1994-2010 by <A HREF="mailto:troyer@comp-phys.org">Matthias Troyer</A></p>
    <p>Distributed under the Boost Software License, Version 1.0. 
    (See http://www.boost.org/LICENSE_1_0.txt)</p>
</ADDRESS>

</body>
</html>

